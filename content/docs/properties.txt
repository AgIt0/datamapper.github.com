--- 
title:      Properties
body_id:    docs
created_at: Tue Dec 04 13:27:16 +1030 2007
filter:
  - erb
  - textile
--- 

h1. <%= @page.title %>

A model's properties are not introspected from the fields in the data-store; In fact the reverse happens. You declare the properties for a model inside it's class definition, which is then used to generate the fields in the data-store.

This has a few advantages. First it means that a model's properties are documented in the model itself, not a migration or XML file. If you've ever been annoyed at having to look in a schema file to see the list of properties and types for a model, you'll find this particularly useful.  There's no need for a special @annotate@ rake task either.

Second, it lets you limit access to properties using Ruby's access semantics. Properties can be declared public, private or protected. They are public by default.

Finally, since DataMapper only cares about properties explicitly defined in your models, DataMapper plays well with legacy data-stores and shares them easily with other applications.

h2. Declaring Properties

Inside your class, call the property method for each property you want to add. The only two required arguments are the name and type, everything else is optional.

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
class Post 
  include DataMapper::Resource
  property :id,         Integer,    :serial => true    # primary serial key
  property :title,      String,     :nullable => false # Cannot be null
  property :published,  Boolean,    :default  => false # Default value for new records is false
end
<% end %>

h2. Available Types

DM-Core supports the following 'primitive' data-types.

* TrueClass, Boolean
* String
* Text
* Float
* Fixnum, Integer
* BigDecimal,
* DateTime, Date
* Object, (marshalled)
* Discriminator

If you include DM-More's DM-Types, the following data-types are supported:

* Csv
* Enum
* EpochTime
* FilePath
* Flag
* IPAddress
* URI
* Yaml
* Json
* BCryptHash
* Regex

h2. Limiting Access

Access for properties is defined using the same semantics as Ruby. Accessors are public by default, but you can declare them as private or protected if you need. You can set access using the @:accessor@ option.  For demonstration, we'll reopen our Post class.

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
class Post 
  property :title,  :string, :accessor => :private   # Both reader and writer are private
  property :body,   :text,   :accessor => :protected # Both reader and writer are protected
end
<% end %>

You also have more fine grained control over how you declare access. You can, for example, have a public reader and private writer by using the @:writer@ and @:reader@ options. (Remember, the default is Public)

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
class Post
  property :title, String, :writer => :private    # Only writer is private
  property :tags,  String, :reader => :protected  # Only reader is protected
end
<% end %>

h2. Over-riding Accessors

When a property has declared accessors for getting and setting, it's values are added to the model. Just like using @attr_accessor@, you can over-ride these with your own custom accessors. It's a simple matter of adding an accessor after the property declaration.  Reopening the Post class....

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
class Post
  property :slug,  String

  def slug=(new_slug)
    raise ArgumentError if new_slug != 'DataMapper is Awesome'
    attribute_set(:slug, new_title)   # use attribute_set instead of talking
                                      # to the @ivars directly.
                                      # This tracks dirtiness.
  end
end
<% end %>

h2. Lazy Loading

Properties can be configured to be lazy loading. A lazily loaded property is not requested from the data-store by default. Instead it is only loaded when it's accessor is called for the first time. This means you can stop default queries from being greedy, a particular problem with text fields. Text fields are lazily loaded by default, which you can over-ride if you need to.

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
class Post
  include DataMapper::Resource
  property :id,     Integer,  :serial => true
  property :title,  String
  property :body,   Text                        # Is lazily loaded by default
  property :notes,  Text,     :lazy => false    # Isn't lazily loaded
end
<% end %>

h2. Primary Keys, Natural Keys, and Composite Keys

<div class="puff">
h2. Important Change

Primary keys are not automatically created for you, as with previous versions
of DataMapper or ActiveRecord.  You MUST configure at least one key property on
your data-store.
</div>

To set your own primary key, and even use a string column as a primary 'natural' key, pass @:key => true@ as an option.

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
class Post
  include DataMapper::Resource
  property :slug,  String, :key => true
end
<% end %>

To use a composite key of any length, simply create more than one property with the @:key => true@ as an option.

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
class Post
  include DataMapper::Resource
  property :old_id, Integer, :key => true
  property :new_id, Integer, :key => true
end
<% end %>
