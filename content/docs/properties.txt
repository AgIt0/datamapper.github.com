--- 
title:      Properties
body_id:    docs
created_at: Tue Dec 04 13:27:16 +1030 2007
filter:
  - erb
  - textile
--- 

h1. <%= @page.title %>

A model's properties are not introspected from the fields in the data-store; In fact the reverse happens. You declare the properties for a model inside it's class definition, which is then used to generate the fields in the data-store.

This has a few advantages. First it means that a model's properties are documented in the model itself, not a migration or XML file. If you've ever been annoyed at having to look in a schema file to see the list of properties and types for a model, you'll find this particularly useful.  There's no need for a special @annotate@ rake task either.

Second, it lets you limit access to properties using Ruby's access semantics. Properties can be declared public, private or protected. They are public by default.

Finally, since DataMapper only cares about properties explicitly defined in your models, DataMapper plays well with legacy data-stores and shares them easily with other applications.

h2. Declaring Properties

Inside your class, call the property method for each property you want to add. The only two required arguments are the name and type, everything else is optional.

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
class Post 
  include DataMapper::Resource
  property :id,         Integer,    :serial => true    # primary serial key
  property :title,      String,     :nullable => false # Cannot be null
  property :published,  Boolean,    :default  => false # Default value for new records is false
end
<% end %>

h2. Available Types

DM-Core supports the following 'primitive' data-types.

* TrueClass, Boolean
* String
* Text
* Float
* Fixnum, Integer
* BigDecimal,
* DateTime, Date
* Object, (marshalled)
* Discriminator

If you include DM-More's DM-Types, the following data-types are supported:

* Csv
* Enum
* EpochTime
* FilePath
* Flag
* IPAddress
* URI
* Yaml
* Json
* BCryptHash
* Regex

h2. Limiting Access

Access for properties is defined using the same semantics as Ruby. Accessors are public by default, but you can declare them as private or protected if you need. You can set access using the @:accessor@ option.  For demonstration, we'll reopen our Post class.

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
class Post 
  property :title,  :string, :accessor => :private   # Both reader and writer are private
  property :body,   :text,   :accessor => :protected # Both reader and writer are protected
end
<% end %>

You also have more fine grained control over how you declare access. You can, for example, have a public reader and private writer by using the @:writer@ and @:reader@ options. (Remember, the default is Public)

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
class Post
  property :title, String, :writer => :private    # Only writer is private
  property :tags,  String, :reader => :protected  # Only reader is protected
end
<% end %>

h2. Over-riding Accessors

When a property has declared accessors for getting and setting, it's values are added to the model. Just like using @attr_accessor@, you can over-ride these with your own custom accessors. It's a simple matter of adding an accessor after the property declaration.  Reopening the Post class....

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
class Post
  property :slug,  String

  def slug=(new_slug)
    raise ArgumentError if new_slug != 'DataMapper is Awesome'
    attribute_set(:slug, new_title)   # use attribute_set instead of talking
                                      # to the @ivars directly.
                                      # This tracks dirtiness.
  end
end
<% end %>

h2. Lazy Loading

Properties can be configured to be lazy loading. A lazily loaded property is not requested from the data-store by default. Instead it is only loaded when it's accessor is called for the first time. This means you can stop default queries from being greedy, a particular problem with text fields. Text fields are lazily loaded by default, which you can over-ride if you need to.

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
class Post
  include DataMapper::Resource
  property :id,     Integer,  :serial => true
  property :title,  String
  property :body,   Text                        # Is lazily loaded by default
  property :notes,  Text,     :lazy => false    # Isn't lazily loaded
end
<% end %>

h2. Primary Keys, Natural Keys, and Composite Keys

<div class="puff">
h2. Important Change

Primary keys are not automatically created for you, as with previous versions
of DataMapper or ActiveRecord.  You MUST configure at least one key property on
your data-store.
</div>

To set your own primary key, and even use a string column as a primary 'natural' key, pass @:key => true@ as an option.

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
class Post
  include DataMapper::Resource
  property :slug,  String, :key => true
end
<% end %>

To use a composite key of any length, simply create more than one property with the @:key => true@ as an option.

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
class Post
  include DataMapper::Resource
  property :old_id, Integer, :key => true
  property :new_id, Integer, :key => true
end
<% end %>

h2. Setting Defaults

Defaults can be set via the @:default@ key for a property.  They can be static values, such as @12@ or @"Hello"@, but DataMapper also offers the ability to use a Proc to set the default value.  The property becomes whatever the Proc returns, which will be called the first time the property is used without having first set a value.  The Proc itself receives two arguments: The resource the property is being set on, and the property itself.

<% coderay(:lang => "ruby", :line_numbers => "inline") do -%>
class Image
  include DataMapper::Resource
  property :id, Serial
  property :path, FilePath, :nullable => false
  property :md5sum, String, :length => 32,
                   :default => Proc.new { |r, p| Digest::MD5.hexdigest(r.path.read) if r.path }
end
<% end %>

On saving the resource, or the first time the @md5sum@ property is accessed, it will be set to the hex digest of the file referred to by @path@.  Using a default in this way, instead of a before <%= link_to_page 'hook', :title => 'Hooks (AKA Callbacks)' %>, has advantages and disadvantages.  By making it a default, the @md5sum@ can easily be used before the resource is saved to the data-store but if the @path@ subsequently changes, the @md5sum@ won't get updated.  Of course, the setter method for @path@ (see further up the page) could be used to set @md5sum@ to @nil@ if the @path@ is changed, removing this problem whilst still allowing the calculation of the sum to be deferred as late as possible.  A word of warning: A property default must _not_ refer to the value of the property it is about to set, or there will be an infinite loop as DataMapper tries to figure out the value of the property, finds it doesn't have one ... and so calls for the default.
